{"name":"SIP Headers","content":"###SIP headers explained (from http://www.openser.org/pipermail/users/2005-September/000839.html): \n\n>When a user agent sends a SIP request, the request will traverse one ore\n>more SIP proxies until it reaches the target user agent. Each proxy and\n>user agent along the path of the request will add its Via header field.\n>The purpose of Via header fields is to make sure that all replies will\n>traverse exactly the same set of proxies (but in reverse order) as the\n>request. In other words Via header fields are used to route _replies_.\n>They record the path of the request so that replies can follow it.\n>\n>Route and Record-Route header fields have a slightly different purpose\n>-- they are used to route _requests_. Let's assume this scenario:\n>\n>       INV               INV\n>UA A --------> proxy ----------> UA B\n>a at 1.2.3.4                        b at 5.6.7.8\n>\n>User agent A with IP address 1.2.3.4 sends an INVITE request to the\n>proxy which forwards the request to user agent B. UA A adds the Contact\n>header field in the request. The Contact header field tells UA B that it\n>can reach UA A on IP 1.2.3.4. UA B adds a Contact header field to 200 OK\n>reply, telling UA A that it can reach B on IP address 5.6.7.8.\n>This way both user agents exchange their IP addresses and they do not\n>need the proxy anymore. They can easily send all further SIP messages\n>directly to each other, because they remember the IP address of the\n>remote party from Contact header field. This way all further requests\n>would bypass the proxy server.\n>\n>There are many cases where the proxy server needs to see _all_ future\n>SIP messages exchanged between the user agent (for example when\n>performing accounting). In this case the proxy server needs tell the\n>user agents that they should not exchange future SIP messages directly,\n>but they should relay them through the proxy again.\n>\n>The proxy server can do this by inserting Record-Route header field in\n>the INVITE message. The Record-Route header field contains the IP\n>address of the proxy and once the INVITE message reaches UA B, it extracts\n>the IP address of the proxy server from Record-Route header field and\n>store it in memory along with the IP address of the remote party (UA A).\n>So UA B knows the IP address of UA A and it also knows that it should\n>send all future requests to UA A through the proxy server.\n>\n>UA A should also send all future SIP requests to UA B through the proxy\n>server, but it does not know it yet, because the proxy server added\n>Record-Route header field to the INVITE message (which will only reach\n>UA B). UA B has to tell UA A that all future SIP requests should be sent\n>through the proxy, and it does so by copying all Record-Route header\n>fields (in our example there will be only one) from the INVITE message to \n>200 OK (which is sent from UA B to UA A). UA A will then extract\n>Record-Route header fields along with Contact from 200 OK and store it\n>in memory. At this point both user agents know the IP address of the\n>remote party and that they should relay all SIP messages through the\n>proxy.\n>\n>Now what happens when UA A wants to send an ACK to UA B. It will lookup\n>the IP address of the remote party (Contact from 200 OK) from memory and put \n>it in the Request-URI of ACK. The reason why ACK does not have the same\n>Request-URI as the original INVITE is that the ACK should be sent to the\n>user agent instance that generated 200 OK -- the Request-URI from the\n>INVITE would fork if user B had several user agents and this is not\n>desirable for ACKs. The URI based on Contact header field never forks,\n>it is delivered only to the UA instance that generated 200 OK.\n>UA A will also find the URI from the Record-Route header field in memory\n>(stored along with the contact of the remote party). It will create a\n>Route header field, put the URI in it and append it to the ACK.\n>\n>RFC3261 says that if there is a Route header field in a SIP message,\n>then the message should not be sent to the URI in the Request-URI, but\n>to the URI in Route header field and thus the ACK would be sent to the\n>proxy. The proxy will then remove the Route header field and because\n>there is no other Route header field in our message, it will forward the\n>request to the Request-URI which will take the message to UA B.\n>\n>Note the difference between Record-Route and Route header fields.\n>Record-Route header fields tell SIP user agent and proxies where\n>_future_ SIP requests should be sent. Route header field are constructed\n>from Record-Route header fields and they tell user agent and proxies\n>where the request that contains the Route header fields should be sent.\n>Two header field names are needed to avoid confusion, because a proxy\n>server can add Record-Route header field to _any_ SIP request, including\n>requests that already contain Route header fields (using the same name\n>would mix them).\n>\n>The relationship between the two user agents (when they remember the IP\n>address of the remote party and IPs of proxies) is called dialog. SIP\n>requests that are forwarded using the information extracted from\n>Contacts and Record-Route header fields are called \"SIP requests within\n>dialog\" (typically ACK and BYE).\n>\n>When a user agent sends a SIP request within a dialog, it will always\n>put the Contact of the remote party in the Request-URI and copy all URIs\n>extracted from Record-Route header fields in Route header fields (in\n>either forward or reverse order, based on the direction):\n>\n>ACK sip:b at 5.6.7.8 SIP/2.0\n>Route: sip:proxy at proxy.ip;lr\n>...\n>\n>This is how all recent SIP implementations should behave. Always put the\n>Contact of the remote party into the Request-URI and list all proxies that\n>inserted Record-Route in Route header fields appended to the message.\n>Plain and simple.\n>\n>Unfortunately there are also older SIP implementations (from pre-RFC3261\n>era) that need special care, because record-routing worked differently\n>then. In this case the Record-Route does not contain the contact of\n>the remote party but the topmost Route header field, and the value of\n>the remote contact is preserved in the last Route header field in the\n>message. This \"compatibility mode\" is what makes record routing complex\n>and hard to understand, but you can ignore it (you can always find\n>details in RFC3261).\n>\n>In conclusion:\n>\n>1) Via is used to route responses\n>2) Route and Record-Route headers are used to route requests\n>3) Proxies use Record-Route to signal that they want to stay on the path\n>   of future requests.\n>4) User agents use Record-Route headers to build Route headers.\n>5) Contact of the remote party is always put in the Request-URI of\n>   requests in dialogs.\n>6) The list of Route header field is created from the list of\n>   Record-Route header fields.\n>7) The URI in the topmost Route header field overrides the URI in the\n>   Request-URI, so the Request-URI will only be used if there are no\n>   more Route header fields.\n>\n>      Jan.\n>\n>PS: When talking to Quintum guys, you should ask them to implement what\n>    I just described:\n>    1) Take the Contact header field from 200 OK and put it in the\n>       Request-URI of ACK.\n>    2) Take all Record-Route header fields from 200 OK, reverse their\n>       order, and append them as Route header fields to the ACK.\n>    3) Send the ACK to the topmost Route, if any, otherwise send to the\n>       Request-URI.","notebook":"e550b552d8cbeaa7","id":"27f78dcc6e60eed7","date":1377667187}